import { create } from 'zustand';
import { db, Product, Category, Supplier, Invoice, StockOpname, StockWaste } from '../db';
import { useShiftStore } from './shiftStore';

interface ProductState {
  products: Product[];
  categories: Category[];
  loading: boolean;
  error: string | null;
  
  fetchProducts: () => Promise<void>;
  fetchCategories: () => Promise<void>;
  addProduct: (product: Omit<Product, 'id' | 'createdAt' | 'updatedAt' | 'deletedAt'>) => Promise<void>;
  updateProduct: (id: string, updates: Partial<Product>) => Promise<void>;
  deleteProduct: (id: string) => Promise<void>;
  addCategory: (category: Omit<Category, 'id' | 'createdAt' | 'updatedAt' | 'deletedAt'>) => Promise<void>;
  updateCategory: (id: string, updates: Partial<Category>) => Promise<void>;
  deleteCategory: (id: string) => Promise<void>;
  getProductsByCategory: (categoryId: string) => Product[];
  searchProducts: (query: string) => Product[];
  initializeProducts: () => Promise<void>;
  
  // Inventory management functions
  addPurchaseInvoice: (invoice: Omit<Invoice, 'id' | 'invoiceNumber' | 'createdAt' | 'updatedAt' | 'deletedAt' | 'shiftId'>) => Promise<void>;
  updateStock: (productId: string, quantity: number, unit: string) => Promise<void>;
  addStockOpname: (opname: Omit<StockOpname, 'id' | 'createdAt' | 'shiftId'>) => Promise<void>;
  addStockWaste: (waste: Omit<StockWaste, 'id' | 'createdAt' | 'shiftId'>) => Promise<void>;
  calculateHPP: (productId: string) => Promise<number>;
  getStockHistory: (productId: string) => Promise<any[]>;
  getLowStockProducts: () => Product[];
  
  // Recipe builder functions
  addRecipe: (recipeProduct: Omit<Product, 'id' | 'createdAt' | 'updatedAt' | 'deletedAt'>) => Promise<void>;
  updateRecipe: (id: string, updates: Partial<Product>) => Promise<void>;
  calculateRecipeStock: (recipeProductId: string) => Promise<number>;
  validateRecipeMaterials: (recipe: { materialId: string; qty: number; unit: string }[]) => Promise<boolean>;
  
  // Supplier management functions
  fetchSuppliers: () => Promise<void>;
  addSupplier: (supplier: Omit<Supplier, 'id' | 'createdAt' | 'updatedAt' | 'deletedAt'>) => Promise<void>;
  updateSupplier: (id: string, updates: Partial<Supplier>) => Promise<void>;
  deleteSupplier: (id: string) => Promise<void>;
  searchSuppliers: (query: string) => Supplier[];
}

export const useProductStore = create<ProductState>((set, get) => ({
  products: [],
  categories: [],
  loading: false,
  error: null,
  
  fetchProducts: async () => {
    set({ loading: true, error: null });
    try {
      const products = await db.products.filter(p => !p.deletedAt).toArray();
      set({ products, loading: false });
    } catch (error: any) {
      set({ error: error.message, loading: false });
    }
 },
  
  fetchCategories: async () => {
    set({ loading: true, error: null });
    try {
      const categories = await db.categories.filter(c => !c.deletedAt).toArray();
      set({ categories, loading: false });
    } catch (error: any) {
      set({ error: error.message, loading: false });
    }
 },
  
  addProduct: async (productData) => {
    set({ loading: true, error: null });
    try {
      const newProduct: Product = {
        ...productData,
        id: '', // Will be auto-generated by DB
        createdAt: new Date(),
        updatedAt: new Date(),
        deletedAt: null,
      };
      
      const id = await db.products.add(newProduct);
      set(state => ({
        products: [...state.products, { ...newProduct, id }],
        loading: false
      }));
    } catch (error: any) {
      set({ error: error.message, loading: false });
    }
 },
  
  updateProduct: async (id, updates) => {
    set({ loading: true, error: null });
    try {
      await db.products.update(id, { ...updates, updatedAt: new Date() });
      set(state => ({
        products: state.products.map(p => p.id === id ? { ...p, ...updates, updatedAt: new Date() } : p),
        loading: false
      }));
    } catch (error: any) {
      set({ error: error.message, loading: false });
    }
 },
  
  deleteProduct: async (id) => {
    set({ loading: true, error: null });
    try {
      // Soft delete by setting deletedAt
      await db.products.update(id, { deletedAt: new Date(), updatedAt: new Date() });
      set(state => ({
        products: state.products.map(p =>
          p.id === id ? { ...p, deletedAt: new Date(), updatedAt: new Date() } : p
        ),
        loading: false
      }));
    } catch (error: any) {
      set({ error: error.message, loading: false });
    }
 },
  
  addCategory: async (categoryData) => {
    set({ loading: true, error: null });
    try {
      const newCategory: Category = {
        ...categoryData,
        id: '', // Will be auto-generated by DB
        createdAt: new Date(),
        updatedAt: new Date(),
        deletedAt: null,
      };
      
      const id = await db.categories.add(newCategory);
      set(state => ({
        categories: [...state.categories, { ...newCategory, id }],
        loading: false
      }));
    } catch (error: any) {
      set({ error: error.message, loading: false });
    }
 },
  
  updateCategory: async (id, updates) => {
    set({ loading: true, error: null });
    try {
      await db.categories.update(id, { ...updates, updatedAt: new Date() });
      set(state => ({
        categories: state.categories.map(c => c.id === id ? { ...c, ...updates, updatedAt: new Date() } : c),
        loading: false
      }));
    } catch (error: any) {
      set({ error: error.message, loading: false });
    }
 },
  
  deleteCategory: async (id) => {
    set({ loading: true, error: null });
    try {
      // Soft delete by setting deletedAt
      await db.categories.update(id, { deletedAt: new Date(), updatedAt: new Date() });
      set(state => ({
        categories: state.categories.map(c =>
          c.id === id ? { ...c, deletedAt: new Date(), updatedAt: new Date() } : c
        ),
        loading: false
      }));
    } catch (error: any) {
      set({ error: error.message, loading: false });
    }
 },
  
  getProductsByCategory: (categoryId) => {
    return get().products.filter(p => p.categoryId === categoryId && !p.deletedAt);
  },
  
  searchProducts: (query) => {
    const { products } = get();
    if (!query) return products.filter(p => !p.deletedAt);
    
    const lowerQuery = query.toLowerCase();
    return products.filter(p =>
      !p.deletedAt &&
      (p.name.toLowerCase().includes(lowerQuery) ||
       (p.sku && p.sku.toLowerCase().includes(lowerQuery)))
    );
 },
  
  initializeProducts: async () => {
    await Promise.all([
      get().fetchProducts(),
      get().fetchCategories()
    ]);
  },
  
  // Inventory management functions
  addPurchaseInvoice: async (invoiceData) => {
    set({ loading: true, error: null });
    try {
      // Generate invoice number
      const invoiceNumber = `INV-${Date.now()}`;
      
      // Get the current shift ID if there's an active shift
      const { currentShiftId } = useShiftStore.getState();
      
      const newInvoice: Invoice = {
        ...invoiceData,
        id: '',
        invoiceNumber,
        shiftId: currentShiftId || null,
        createdAt: new Date(),
        updatedAt: new Date(),
        deletedAt: null,
      };
      
      const id = await db.invoices.add(newInvoice);
      
      // Update stock for each item in the invoice
      for (const item of invoiceData.items) {
        const product = await db.products.get(item.productId);
        if (product) {
          const newCurrentStock = (product.currentStock || 0) + item.qty;
          // Update HPP (Average Cost) - simple average calculation
          let newCost = product.cost;
          if (product.cost === 0) {
            newCost = item.unitPrice;
          } else {
            const totalValue = (product.currentStock * product.cost) + (item.qty * item.unitPrice);
            newCost = totalValue / newCurrentStock;
          }
          
          await db.products.update(item.productId, {
            currentStock: newCurrentStock,
            cost: newCost,
            updatedAt: new Date()
          });
        }
      }
      
      // Refresh products after stock update
      const updatedProducts = await db.products.filter(p => !p.deletedAt).toArray();
      set({ products: updatedProducts, loading: false });
    } catch (error: any) {
      set({ error: error.message, loading: false });
    }
  },
  
  updateStock: async (productId, quantity, unit) => {
    set({ loading: true, error: null });
    try {
      const product = await db.products.get(productId);
      if (!product) {
        throw new Error("Product not found");
      }
      
      // Update stock
      await db.products.update(productId, {
        currentStock: (product.currentStock || 0) + quantity,
        updatedAt: new Date()
      });
      
      // Refresh products
      const updatedProducts = await db.products.filter(p => !p.deletedAt).toArray();
      set({ products: updatedProducts, loading: false });
    } catch (error: any) {
      set({ error: error.message, loading: false });
    }
  },
  
  addStockOpname: async (opnameData) => {
    set({ loading: true, error: null });
    try {
      // Get the current shift ID if there's an active shift
      const { currentShiftId } = useShiftStore.getState();
      
      const newOpname: StockOpname = {
        ...opnameData,
        id: '',
        shiftId: currentShiftId || null,
        createdAt: new Date(),
      };
      
      const id = await db.stockOpnames.add(newOpname);
      
      // Update stock based on opname results
      for (const item of opnameData.items) {
        await db.products.update(item.productId, {
          currentStock: item.actualStock,
          updatedAt: new Date()
        });
      }
      
      // Refresh products after stock update
      const updatedProducts = await db.products.filter(p => !p.deletedAt).toArray();
      set({ products: updatedProducts, loading: false });
    } catch (error: any) {
      set({ error: error.message, loading: false });
    }
  },
  
  addStockWaste: async (wasteData) => {
    set({ loading: true, error: null });
    try {
      // Get the current shift ID if there's an active shift
      const { currentShiftId } = useShiftStore.getState();
      
      const newWaste: StockWaste = {
        ...wasteData,
        id: '',
        shiftId: currentShiftId || null,
        createdAt: new Date(),
      };
      
      const id = await db.stockWastes.add(newWaste);
      
      // Reduce stock for the wasted item
      const product = await db.products.get(wasteData.productId);
      if (product) {
        const newCurrentStock = Math.max(0, (product.currentStock || 0) - wasteData.qty);
        await db.products.update(wasteData.productId, {
          currentStock: newCurrentStock,
          updatedAt: new Date()
        });
      }
      
      // Refresh products after stock update
      const updatedProducts = await db.products.filter(p => !p.deletedAt).toArray();
      set({ products: updatedProducts, loading: false });
    } catch (error: any) {
      set({ error: error.message, loading: false });
    }
  },
  
  calculateHPP: async (productId) => {
    // TODO: Implement proper HPP calculation based on purchase history
    // For now, return the current cost as HPP
    const product = await db.products.get(productId);
    return product ? product.cost : 0;
  },
  
  getStockHistory: async (productId) => {
    // TODO: Implement stock history tracking
    // This would return stock history including purchase invoices, opnames, and waste records
    return [];
  },
  
  getLowStockProducts: () => {
    // Return products where current stock is below minimum stock level
    return get().products.filter(p =>
      p.monitorStock && p.minStock && p.currentStock <= p.minStock
    );
  },
  
  // Recipe builder functions
  addRecipe: async (recipeProductData) => {
    set({ loading: true, error: null });
    try {
      // Validate that this is a recipe product
      if (recipeProductData.type !== 'recipe_goods') {
        throw new Error("Product must be of type 'recipe_goods' to be a recipe");
      }
      
      // Validate recipe materials
      if (recipeProductData.recipe && recipeProductData.recipe.length > 0) {
        const isValid = await get().validateRecipeMaterials(recipeProductData.recipe);
        if (!isValid) {
          throw new Error("One or more recipe materials are invalid or insufficient in stock");
        }
      }
      
      const newRecipeProduct: Product = {
        ...recipeProductData,
        id: '', // Will be auto-generated by DB
        createdAt: new Date(),
        updatedAt: new Date(),
        deletedAt: null,
      };
      
      const id = await db.products.add(newRecipeProduct);
      set(state => ({
        products: [...state.products, { ...newRecipeProduct, id }],
        loading: false
      }));
    } catch (error: any) {
      set({ error: error.message, loading: false });
    }
  },
  
  updateRecipe: async (id, updates) => {
    set({ loading: true, error: null });
    try {
      // Validate recipe materials if updating recipe
      if (updates.recipe && updates.recipe.length > 0) {
        const isValid = await get().validateRecipeMaterials(updates.recipe);
        if (!isValid) {
          throw new Error("One or more recipe materials are invalid or insufficient in stock");
        }
      }
      
      await db.products.update(id, { ...updates, updatedAt: new Date() });
      set(state => ({
        products: state.products.map(p => p.id === id ? { ...p, ...updates, updatedAt: new Date() } : p),
        loading: false
      }));
    } catch (error: any) {
      set({ error: error.message, loading: false });
    }
  },
  
  calculateRecipeStock: async (recipeProductId) => {
    try {
      const recipeProduct = await db.products.get(recipeProductId);
      if (!recipeProduct || recipeProduct.type !== 'recipe_goods' || !recipeProduct.recipe) {
        return 0;
      }
      
      // Calculate the maximum number of recipes that can be made based on available materials
      let minPossibleRecipes = Infinity;
      
      for (const material of recipeProduct.recipe) {
        const materialProduct = await db.products.get(material.materialId);
        if (!materialProduct) {
          return 0; // Material not found, can't make recipe
        }
        
        // Calculate how many recipes can be made with this material
        const possibleRecipes = Math.floor((materialProduct.currentStock || 0) / material.qty);
        minPossibleRecipes = Math.min(minPossibleRecipes, possibleRecipes);
      }
      
      return minPossibleRecipes === Infinity ? 0 : minPossibleRecipes;
    } catch (error: any) {
      console.error("Error calculating recipe stock:", error);
      return 0;
    }
  },
  
  validateRecipeMaterials: async (recipe) => {
    try {
      // Check if all materials exist and have sufficient stock
      for (const material of recipe) {
        const materialProduct = await db.products.get(material.materialId);
        if (!materialProduct) {
          return false; // Material not found
        }
        
        // Check if material has sufficient stock
        if ((materialProduct.currentStock || 0) < material.qty) {
          return false; // Insufficient stock
        }
      }
      
      return true; // All materials are valid and sufficient
    } catch (error) {
      return false; // Error occurred during validation
    }
  },
  
  // Supplier management functions
  fetchSuppliers: async () => {
    set({ loading: true, error: null });
    try {
      const suppliers = await db.suppliers.filter(s => !s.deletedAt).toArray();
      // We're storing suppliers in the products store for now, but in a real app this would be in a separate supplier store
      console.log("Fetched suppliers:", suppliers);
      set({ loading: false });
    } catch (error: any) {
      set({ error: error.message, loading: false });
    }
  },
  
  addSupplier: async (supplierData) => {
    set({ loading: true, error: null });
    try {
      const newSupplier: Supplier = {
        ...supplierData,
        id: '', // Will be auto-generated by DB
        createdAt: new Date(),
        updatedAt: new Date(),
        deletedAt: null,
      };
      
      const id = await db.suppliers.add(newSupplier);
      console.log("Added supplier with ID:", id);
      set({ loading: false });
    } catch (error: any) {
      set({ error: error.message, loading: false });
    }
  },
  
  updateSupplier: async (id, updates) => {
    set({ loading: true, error: null });
    try {
      await db.suppliers.update(id, { ...updates, updatedAt: new Date() });
      console.log("Updated supplier with ID:", id);
      set({ loading: false });
    } catch (error: any) {
      set({ error: error.message, loading: false });
    }
  },
  
  deleteSupplier: async (id) => {
    set({ loading: true, error: null });
    try {
      // Soft delete by setting deletedAt
      await db.suppliers.update(id, { deletedAt: new Date(), updatedAt: new Date() });
      console.log("Deleted supplier with ID:", id);
      set({ loading: false });
    } catch (error: any) {
      set({ error: error.message, loading: false });
    }
  },
  
  searchSuppliers: (query) => {
    // TODO: Implement supplier search functionality
    return [];
  }
}));